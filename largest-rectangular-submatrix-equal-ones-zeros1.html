<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem Statement Matrix Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #FFFFFF;
            color: #000000;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        h1 {
            color: #FF4800;
            margin-bottom: 30px;
        }
        .matrix-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px 0;
        }
        .matrix {
            display: grid;
            grid-template-columns: repeat(4, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            margin-bottom: 20px;
        }
        .cell {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            border: 2px solid #000000;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        .highlight {
            background-color: #FD9F78;
            transform: scale(1.05);
        }
        .explanation {
            margin: 20px 0;
            text-align: left;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
            border-left: 5px solid #FF4800;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        .nav-btn {
            padding: 10px 20px;
            background-color: #FF4800;
            color: #FFFFFF;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .nav-btn:hover {
            background-color: #FD9F78;
        }
        .nav-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .step-indicator {
            margin-top: 15px;
            font-weight: bold;
            color: #FF4800;
        }
        .rectangle {
            position: absolute;
            border: 3px solid #FF4800;
            pointer-events: none;
            transition: all 0.5s ease;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Problem Statement: Matrix with Largest Rectangle</h1>
        
        <div class="matrix-container">
            <div class="matrix" id="matrix">
                <!-- Matrix cells will be generated by JavaScript -->
            </div>
            <div id="rectangle" class="rectangle"></div>
        </div>

        <div class="explanation" id="explanation">
            <p>This visualization demonstrates a problem involving finding the largest rectangle in a binary matrix.</p>
            <p>In this example, we have a 3×4 binary matrix where each cell contains either a 0 or a 1.</p>
            <p>Click "Next" to see the largest rectangular area that includes both 1's and 0's.</p>
        </div>

        <div class="step-indicator" id="step-indicator">Step 1 of 3</div>

        <div class="navigation">
            <button class="nav-btn" id="prev-btn" disabled>Previous</button>
            <button class="nav-btn" id="next-btn">Next</button>
        </div>
    </div>

    <script>
        // Define the matrix with values
        const matrixValues = [
            [1, 0, 1, 0],
            [1, 0, 1, 0],
            [0, 1, 0, 1]
        ];

        // Get elements
        const matrixElement = document.getElementById('matrix');
        const explanationElement = document.getElementById('explanation');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const stepIndicator = document.getElementById('step-indicator');
        const rectangleElement = document.getElementById('rectangle');

        // Create matrix cells
        function createMatrix() {
            matrixElement.innerHTML = '';
            for (let i = 0; i < matrixValues.length; i++) {
                for (let j = 0; j < matrixValues[i].length; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${i}-${j}`;
                    cell.textContent = matrixValues[i][j];
                    matrixElement.appendChild(cell);
                }
            }
        }

        // Animation steps
        const steps = [
            {
                explanation: "This is a 3×4 binary matrix. Each cell contains either a 0 or a 1. The challenge is to find the largest rectangular area that can form a specific pattern.",
                highlight: [],
                showRectangle: false
            },
            {
                explanation: "Let's examine the first two rows of the matrix. This forms a 2×4 rectangle containing eight cells. Notice that four of these cells contain 1's (highlighted in orange) and four contain 0's.",
                highlight: [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [1, 2], [1, 3]],
                showRectangle: true,
                rectangleCoords: {
                    top: 0,
                    left: 0,
                    width: 4,
                    height: 2
                }
            },
            {
                explanation: "This 2×4 rectangle is the largest rectangle in this matrix that contains an equal number of 0's and 1's (four of each). This balance of values is what makes this rectangle special for our problem statement.",
                highlight: [[0, 0], [0, 2], [1, 0], [1, 2]],  // Highlighting just the 1's
                showRectangle: true,
                rectangleCoords: {
                    top: 0,
                    left: 0,
                    width: 4,
                    height: 2
                }
            }
        ];

        // Current step
        let currentStep = 0;

        // Initialize
        createMatrix();
        updateStep();

        // Update display based on current step
        function updateStep() {
            // Update step indicator
            stepIndicator.textContent = `Step ${currentStep + 1} of ${steps.length}`;
            
            // Update explanation
            explanationElement.innerHTML = `<p>${steps[currentStep].explanation}</p>`;
            
            // Reset all highlights
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('highlight');
            });
            
            // Apply new highlights
            steps[currentStep].highlight.forEach(coord => {
                const cell = document.getElementById(`cell-${coord[0]}-${coord[1]}`);
                if (cell) {
                    cell.classList.add('highlight');
                }
            });
            
            // Update rectangle visibility and position
            if (steps[currentStep].showRectangle) {
                const firstCell = document.getElementById(`cell-${steps[currentStep].rectangleCoords.top}-${steps[currentStep].rectangleCoords.left}`);
                const cellWidth = 60; // width of a cell
                const cellHeight = 60; // height of a cell
                const gapSize = 5; // gap between cells
                
                const rect = steps[currentStep].rectangleCoords;
                const rectWidth = rect.width * (cellWidth + gapSize) - gapSize;
                const rectHeight = rect.height * (cellHeight + gapSize) - gapSize;
                
                const firstCellRect = firstCell.getBoundingClientRect();
                const matrixRect = matrixElement.getBoundingClientRect();
                
                rectangleElement.style.display = 'block';
                rectangleElement.style.left = `${firstCellRect.left - matrixRect.left - 3}px`;
                rectangleElement.style.top = `${firstCellRect.top - matrixRect.top - 3}px`;
                rectangleElement.style.width = `${rectWidth}px`;
                rectangleElement.style.height = `${rectHeight}px`;
            } else {
                rectangleElement.style.display = 'none';
            }
            
            // Update button states
            prevBtn.disabled = currentStep === 0;
            nextBtn.disabled = currentStep === steps.length - 1;
        }

        // Event listeners for navigation buttons
        prevBtn.addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                updateStep();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentStep < steps.length - 1) {
                currentStep++;
                updateStep();
            }
        });
    </script>
</body>
</html>