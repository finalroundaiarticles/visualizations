<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Programming State Transition</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #FFFFFF;
            margin: 0;
            padding: 20px;
            color: #000000;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            color: #FF4800;
            text-align: center;
            margin-bottom: 30px;
        }
        .animation-container {
            border: 2px solid #FD9F78;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 500px;
            position: relative;
        }
        .station {
            display: flex;
            margin-bottom: 40px;
            position: relative;
        }
        .line {
            display: flex;
            margin-bottom: 20px;
        }
        .station-node {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #FD9F78;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000000;
            position: relative;
            margin-right: 150px;
        }
        .station-node.highlighted {
            background-color: #FF4800;
            color: #FFFFFF;
            box-shadow: 0 0 10px rgba(255, 72, 0, 0.7);
        }
        .station-label {
            position: absolute;
            top: -25px;
            left: 0;
            width: 100%;
            text-align: center;
            font-weight: bold;
        }
        .time-label {
            position: absolute;
            top: 70px;
            left: 0;
            width: 100%;
            text-align: center;
        }
        .arrow {
            position: absolute;
            height: 2px;
            background-color: #000000;
            top: 30px;
            transform-origin: left center;
        }
        .arrow::after {
            content: '';
            position: absolute;
            right: -8px;
            top: -4px;
            width: 0;
            height: 0;
            border-left: 10px solid #000000;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
        }
        .transfer-arrow {
            position: absolute;
            width: 2px;
            background-color: #FF4800;
            left: 30px;
            transform-origin: center top;
        }
        .transfer-arrow::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: -4px;
            width: 0;
            height: 0;
            border-top: 10px solid #FF4800;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
        }
        .line-label {
            position: absolute;
            left: -80px;
            top: 20px;
            font-weight: bold;
            color: #FF4800;
        }
        .calculation-box {
            background-color: rgba(253, 159, 120, 0.1);
            border: 1px solid #FD9F78;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            font-size: 16px;
            line-height: 1.5;
        }
        .calculation {
            margin-bottom: 10px;
        }
        .highlight {
            color: #FF4800;
            font-weight: bold;
        }
        .navigation {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        .nav-button {
            background-color: #FF4800;
            color: #FFFFFF;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .nav-button:hover {
            background-color: #FD9F78;
        }
        .nav-button:disabled {
            background-color: #FD9F78;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .step-indicator {
            text-align: center;
            margin-top: 10px;
            color: #FF4800;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dynamic Programming State Transition</h1>
        <div class="animation-container" id="animation">
            <!-- Content will be dynamically generated by JavaScript -->
        </div>
        
        <div class="navigation">
            <button class="nav-button" id="prevBtn" disabled>Previous</button>
            <button class="nav-button" id="nextBtn">Next</button>
        </div>
        <div class="step-indicator" id="stepIndicator">Step 1 of 7</div>
    </div>

    <script>
        const animationContainer = document.getElementById('animation');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const stepIndicator = document.getElementById('stepIndicator');
        
        // Define the example data
        const a1 = [0, 2, 3, 1]; // processing time at station i on line 1 (index 0 is ignored)
        const a2 = [0, 3, 1, 2]; // processing time at station i on line 2 (index 0 is ignored)
        const t1 = [0, 0, 2, 2]; // transfer time from line 1 to line 2 (index 0 is ignored)
        const t2 = [0, 0, 3, 1]; // transfer time from line 2 to line 1 (index 0 is ignored)
        const e1 = 1; // entry time for line 1
        const e2 = 2; // entry time for line 2
        const x1 = 2; // exit time for line 1
        const x2 = 1; // exit time for line 2
        
        // Calculate the DP solution
        const n = 3; // Number of stations
        const f1 = [0, 0, 0, 0]; // Minimum time to reach station i on line 1
        const f2 = [0, 0, 0, 0]; // Minimum time to reach station i on line 2
        
        // Initial values
        f1[1] = e1 + a1[1];
        f2[1] = e2 + a2[1];
        
        // Animation steps
        const steps = [
            {
                title: "Initial Setup",
                description: "We have 3 stations and 2 assembly lines. For each station, we need to determine the minimum time to reach it on each line.",
                calculations: [
                    `Line 1 entry time (e1) = ${e1}`,
                    `Line 2 entry time (e2) = ${e2}`,
                    `Initial values: f1[1] = e1 + a1[1] = ${e1} + ${a1[1]} = ${f1[1]}`,
                    `Initial values: f2[1] = e2 + a2[1] = ${e2} + ${a2[1]} = ${f2[1]}`
                ],
                f1Values: [...f1],
                f2Values: [...f2],
                highlightNodes: [],
                highlightPaths: []
            }
        ];
        
        // Calculate for station 2
        const stayOnLine1ToStation2 = f1[1] + a1[2];
        const transferToLine1AtStation2 = f2[1] + t2[2] + a1[2];
        if (stayOnLine1ToStation2 <= transferToLine1AtStation2) {
            f1[2] = stayOnLine1ToStation2;
            steps.push({
                title: "Calculate f1[2]",
                description: "We need to determine the minimum time to reach station 2 on line 1.",
                calculations: [
                    `Option 1: Stay on line 1: f1[1] + a1[2] = ${f1[1]} + ${a1[2]} = ${stayOnLine1ToStation2}`,
                    `Option 2: Transfer from line 2: f2[1] + t2[2] + a1[2] = ${f2[1]} + ${t2[2]} + ${a1[2]} = ${transferToLine1AtStation2}`,
                    `Since ${stayOnLine1ToStation2} ≤ ${transferToLine1AtStation2}, we choose Option 1.`,
                    `Therefore, f1[2] = ${f1[2]}`
                ],
                f1Values: [0, f1[1], f1[2], 0],
                f2Values: [0, f2[1], 0, 0],
                highlightNodes: [{line: 1, station: 2}],
                highlightPaths: [{from: {line: 1, station: 1}, to: {line: 1, station: 2}}]
            });
        } else {
            f1[2] = transferToLine1AtStation2;
            steps.push({
                title: "Calculate f1[2]",
                description: "We need to determine the minimum time to reach station 2 on line 1.",
                calculations: [
                    `Option 1: Stay on line 1: f1[1] + a1[2] = ${f1[1]} + ${a1[2]} = ${stayOnLine1ToStation2}`,
                    `Option 2: Transfer from line 2: f2[1] + t2[2] + a1[2] = ${f2[1]} + ${t2[2]} + ${a1[2]} = ${transferToLine1AtStation2}`,
                    `Since ${transferToLine1AtStation2} < ${stayOnLine1ToStation2}, we choose Option 2.`,
                    `Therefore, f1[2] = ${f1[2]}`
                ],
                f1Values: [0, f1[1], f1[2], 0],
                f2Values: [0, f2[1], 0, 0],
                highlightNodes: [{line: 1, station: 2}],
                highlightPaths: [{from: {line: 2, station: 1}, to: {line: 1, station: 2}}]
            });
        }
        
        const stayOnLine2ToStation2 = f2[1] + a2[2];
        const transferToLine2AtStation2 = f1[1] + t1[2] + a2[2];
        if (stayOnLine2ToStation2 <= transferToLine2AtStation2) {
            f2[2] = stayOnLine2ToStation2;
            steps.push({
                title: "Calculate f2[2]",
                description: "We need to determine the minimum time to reach station 2 on line 2.",
                calculations: [
                    `Option 1: Stay on line 2: f2[1] + a2[2] = ${f2[1]} + ${a2[2]} = ${stayOnLine2ToStation2}`,
                    `Option 2: Transfer from line 1: f1[1] + t1[2] + a2[2] = ${f1[1]} + ${t1[2]} + ${a2[2]} = ${transferToLine2AtStation2}`,
                    `Since ${stayOnLine2ToStation2} ≤ ${transferToLine2AtStation2}, we choose Option 1.`,
                    `Therefore, f2[2] = ${f2[2]}`
                ],
                f1Values: [0, f1[1], f1[2], 0],
                f2Values: [0, f2[1], f2[2], 0],
                highlightNodes: [{line: 2, station: 2}],
                highlightPaths: [{from: {line: 2, station: 1}, to: {line: 2, station: 2}}]
            });
        } else {
            f2[2] = transferToLine2AtStation2;
            steps.push({
                title: "Calculate f2[2]",
                description: "We need to determine the minimum time to reach station 2 on line 2.",
                calculations: [
                    `Option 1: Stay on line 2: f2[1] + a2[2] = ${f2[1]} + ${a2[2]} = ${stayOnLine2ToStation2}`,
                    `Option 2: Transfer from line 1: f1[1] + t1[2] + a2[2] = ${f1[1]} + ${t1[2]} + ${a2[2]} = ${transferToLine2AtStation2}`,
                    `Since ${transferToLine2AtStation2} < ${stayOnLine2ToStation2}, we choose Option 2.`,
                    `Therefore, f2[2] = ${f2[2]}`
                ],
                f1Values: [0, f1[1], f1[2], 0],
                f2Values: [0, f2[1], f2[2], 0],
                highlightNodes: [{line: 2, station: 2}],
                highlightPaths: [{from: {line: 1, station: 1}, to: {line: 2, station: 2}}]
            });
        }
        
        // Calculate for station 3
        const stayOnLine1ToStation3 = f1[2] + a1[3];
        const transferToLine1AtStation3 = f2[2] + t2[3] + a1[3];
        if (stayOnLine1ToStation3 <= transferToLine1AtStation3) {
            f1[3] = stayOnLine1ToStation3;
            steps.push({
                title: "Calculate f1[3]",
                description: "We need to determine the minimum time to reach station 3 on line 1.",
                calculations: [
                    `Option 1: Stay on line 1: f1[2] + a1[3] = ${f1[2]} + ${a1[3]} = ${stayOnLine1ToStation3}`,
                    `Option 2: Transfer from line 2: f2[2] + t2[3] + a1[3] = ${f2[2]} + ${t2[3]} + ${a1[3]} = ${transferToLine1AtStation3}`,
                    `Since ${stayOnLine1ToStation3} ≤ ${transferToLine1AtStation3}, we choose Option 1.`,
                    `Therefore, f1[3] = ${f1[3]}`
                ],
                f1Values: [0, f1[1], f1[2], f1[3]],
                f2Values: [0, f2[1], f2[2], 0],
                highlightNodes: [{line: 1, station: 3}],
                highlightPaths: [{from: {line: 1, station: 2}, to: {line: 1, station: 3}}]
            });
        } else {
            f1[3] = transferToLine1AtStation3;
            steps.push({
                title: "Calculate f1[3]",
                description: "We need to determine the minimum time to reach station 3 on line 1.",
                calculations: [
                    `Option 1: Stay on line 1: f1[2] + a1[3] = ${f1[2]} + ${a1[3]} = ${stayOnLine1ToStation3}`,
                    `Option 2: Transfer from line 2: f2[2] + t2[3] + a1[3] = ${f2[2]} + ${t2[3]} + ${a1[3]} = ${transferToLine1AtStation3}`,
                    `Since ${transferToLine1AtStation3} < ${stayOnLine1ToStation3}, we choose Option 2.`,
                    `Therefore, f1[3] = ${f1[3]}`
                ],
                f1Values: [0, f1[1], f1[2], f1[3]],
                f2Values: [0, f2[1], f2[2], 0],
                highlightNodes: [{line: 1, station: 3}],
                highlightPaths: [{from: {line: 2, station: 2}, to: {line: 1, station: 3}}]
            });
        }
        
        const stayOnLine2ToStation3 = f2[2] + a2[3];
        const transferToLine2AtStation3 = f1[2] + t1[3] + a2[3];
        if (stayOnLine2ToStation3 <= transferToLine2AtStation3) {
            f2[3] = stayOnLine2ToStation3;
            steps.push({
                title: "Calculate f2[3]",
                description: "We need to determine the minimum time to reach station 3 on line 2.",
                calculations: [
                    `Option 1: Stay on line 2: f2[2] + a2[3] = ${f2[2]} + ${a2[3]} = ${stayOnLine2ToStation3}`,
                    `Option 2: Transfer from line 1: f1[2] + t1[3] + a2[3] = ${f1[2]} + ${t1[3]} + ${a2[3]} = ${transferToLine2AtStation3}`,
                    `Since ${stayOnLine2ToStation3} ≤ ${transferToLine2AtStation3}, we choose Option 1.`,
                    `Therefore, f2[3] = ${f2[3]}`
                ],
                f1Values: [0, f1[1], f1[2], f1[3]],
                f2Values: [0, f2[1], f2[2], f2[3]],
                highlightNodes: [{line: 2, station: 3}],
                highlightPaths: [{from: {line: 2, station: 2}, to: {line: 2, station: 3}}]
            });
        } else {
            f2[3] = transferToLine2AtStation3;
            steps.push({
                title: "Calculate f2[3]",
                description: "We need to determine the minimum time to reach station 3 on line 2.",
                calculations: [
                    `Option 1: Stay on line 2: f2[2] + a2[3] = ${f2[2]} + ${a2[3]} = ${stayOnLine2ToStation3}`,
                    `Option 2: Transfer from line 1: f1[2] + t1[3] + a2[3] = ${f1[2]} + ${t1[3]} + ${a2[3]} = ${transferToLine2AtStation3}`,
                    `Since ${transferToLine2AtStation3} < ${stayOnLine2ToStation3}, we choose Option 2.`,
                    `Therefore, f2[3] = ${f2[3]}`
                ],
                f1Values: [0, f1[1], f1[2], f1[3]],
                f2Values: [0, f2[1], f2[2], f2[3]],
                highlightNodes: [{line: 2, station: 3}],
                highlightPaths: [{from: {line: 1, station: 2}, to: {line: 2, station: 3}}]
            });
        }
        
        // Calculate the final result
        const exitFromLine1 = f1[3] + x1;
        const exitFromLine2 = f2[3] + x2;
        const finalTime = Math.min(exitFromLine1, exitFromLine2);
        const finalPath = (exitFromLine1 <= exitFromLine2) ? 1 : 2;
        
        steps.push({
            title: "Calculate Final Result",
            description: "We need to determine which exit path gives the minimum total time.",
            calculations: [
                `Exit from line 1: f1[3] + x1 = ${f1[3]} + ${x1} = ${exitFromLine1}`,
                `Exit from line 2: f2[3] + x2 = ${f2[3]} + ${x2} = ${exitFromLine2}`,
                `The minimum total time is ${finalTime} by exiting from line ${finalPath}.`
            ],
            f1Values: [0, f1[1], f1[2], f1[3]],
            f2Values: [0, f2[1], f2[2], f2[3]],
            highlightNodes: [{line: finalPath, station: 3}],
            highlightPaths: []
        });
        
        // Current step
        let currentStep = 0;
        
        // Function to render the current step
        function renderStep() {
            const step = steps[currentStep];
            
            // Clear the container
            animationContainer.innerHTML = '';
            
            // Add title
            const titleElement = document.createElement('h2');
            titleElement.textContent = step.title;
            titleElement.style.color = '#FF4800';
            animationContainer.appendChild(titleElement);
            
            // Add description
            const descElement = document.createElement('p');
            descElement.textContent = step.description;
            animationContainer.appendChild(descElement);
            
            // Create assembly lines
            const linesContainer = document.createElement('div');
            linesContainer.className = 'lines-container';
            
            // Line 1
            const line1 = document.createElement('div');
            line1.className = 'line';
            
            const line1Label = document.createElement('div');
            line1Label.className = 'line-label';
            line1Label.textContent = 'Line 1';
            line1.appendChild(line1Label);
            
            for (let i = 1; i <= 3; i++) {
                const stationNode = document.createElement('div');
                stationNode.className = 'station-node';
                
                // Check if this node should be highlighted
                if (step.highlightNodes.some(node => node.line === 1 && node.station === i)) {
                    stationNode.classList.add('highlighted');
                }
                
                stationNode.textContent = step.f1Values[i] || '?';
                
                const stationLabel = document.createElement('div');
                stationLabel.className = 'station-label';
                stationLabel.textContent = `Station ${i}`;
                
                const timeLabel = document.createElement('div');
                timeLabel.className = 'time-label';
                timeLabel.textContent = `a1[${i}] = ${a1[i]}`;
                
                stationNode.appendChild(stationLabel);
                stationNode.appendChild(timeLabel);
                line1.appendChild(stationNode);
                
                // Add horizontal arrows between nodes
                if (i < 3) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.style.left = '60px';
                    arrow.style.width = '90px';
                    line1.appendChild(arrow);
                }
            }
            
            linesContainer.appendChild(line1);
            
            // Line 2
            const line2 = document.createElement('div');
            line2.className = 'line';
            
            const line2Label = document.createElement('div');
            line2Label.className = 'line-label';
            line2Label.textContent = 'Line 2';
            line2.appendChild(line2Label);
            
            for (let i = 1; i <= 3; i++) {
                const stationNode = document.createElement('div');
                stationNode.className = 'station-node';
                
                // Check if this node should be highlighted
                if (step.highlightNodes.some(node => node.line === 2 && node.station === i)) {
                    stationNode.classList.add('highlighted');
                }
                
                stationNode.textContent = step.f2Values[i] || '?';
                
                const stationLabel = document.createElement('div');
                stationLabel.className = 'station-label';
                stationLabel.textContent = `Station ${i}`;
                
                const timeLabel = document.createElement('div');
                timeLabel.className = 'time-label';
                timeLabel.textContent = `a2[${i}] = ${a2[i]}`;
                
                stationNode.appendChild(stationLabel);
                stationNode.appendChild(timeLabel);
                line2.appendChild(stationNode);
                
                // Add horizontal arrows between nodes
                if (i < 3) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.style.left = '60px';
                    arrow.style.width = '90px';
                    line2.appendChild(arrow);
                }
            }
            
            linesContainer.appendChild(line2);
            animationContainer.appendChild(linesContainer);
            
            // Add transfer arrows
            for (const path of step.highlightPaths) {
                if (path.from.line !== path.to.line) {
                    const transferArrow = document.createElement('div');
                    transferArrow.className = 'transfer-arrow';
                    
                    // Position the arrow
                    const fromLine = path.from.line === 1 ? line1 : line2;
                    const toLine = path.to.line === 1 ? line1 : line2;
                    
                    const fromNode = fromLine.children[path.from.station];
                    const toNode = toLine.children[path.to.station];
                    
                    // Calculate position
                    transferArrow.style.height = '150px';
                    transferArrow.style.left = `${(path.from.station * 150) + 30}px`;
                    transferArrow.style.top = path.from.line === 1 ? '60px' : '210px';
                    
                    animationContainer.appendChild(transferArrow);
                }
            }
            
            // Add calculation box
            const calculationBox = document.createElement('div');
            calculationBox.className = 'calculation-box';
            
            for (const calc of step.calculations) {
                const calculation = document.createElement('div');
                calculation.className = 'calculation';
                calculation.innerHTML = calc.replace(/Option \d:/, match => `<span class="highlight">${match}</span>`);
                calculationBox.appendChild(calculation);
            }
            
            animationContainer.appendChild(calculationBox);
            
            // Update step indicator
            stepIndicator.textContent = `Step ${currentStep + 1} of ${steps.length}`;
            
            // Update navigation buttons
            prevBtn.disabled = currentStep === 0;
            nextBtn.disabled = currentStep === steps.length - 1;
        }
        
        // Event listeners for navigation buttons
        prevBtn.addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                renderStep();
            }
        });
        
        nextBtn.addEventListener('click', () => {
            if (currentStep < steps.length - 1) {
                currentStep++;
                renderStep();
            }
        });
        
        // Initial render
        renderStep();
    </script>
</body>
</html>